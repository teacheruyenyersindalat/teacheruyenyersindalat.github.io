<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Turtle Rescue - Eco Warrior</title>
<style>
    body {
        margin: 0; padding: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden; height: 100vh; background: #0f2027;
        user-select: none; -webkit-user-select: none;
    }
    .main-container { display: flex; height: 100%; width: 100%; background: #0f172a; position: relative; }
    .main-container.fullscreen-fallback { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 9999; background: #0f2027; }
    
    /* FOOTER */
    .copyright-footer {
        position: absolute; bottom: 10px; left: 0; width: 100%; text-align: center;
        color: #fcd34d; font-size: 11px; font-weight: 700; pointer-events: none; 
        z-index: 10000; letter-spacing: 1.5px; font-family: 'Segoe UI', sans-serif;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9); text-transform: uppercase;
    }

    /* GAME AREA */
    .game-area {
        flex: 1; position: relative; overflow: hidden;
        background: linear-gradient(to bottom, #1e3a8a, #0ea5e9); 
        cursor: crosshair; border-right: 4px solid #0f172a;
    }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }

    /* UI */
    .game-header {
        position: absolute; top: 0; left: 0; width: 100%; padding: 15px 20px;
        display: flex; justify-content: space-between; align-items: flex-start; 
        pointer-events: none; z-index: 10; box-sizing: border-box;
    }
    .stat-group { display: flex; gap: 15px; align-items: center; }
    .control-group { display: flex; gap: 10px; pointer-events: auto; }
    .icon-btn {
        background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.4); color: white; width: 40px; height: 40px;
        border-radius: 10px; display: flex; justify-content: center; align-items: center;
        cursor: pointer; font-size: 20px; transition: all 0.2s;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .icon-btn:hover { background: rgba(255, 255, 255, 0.4); transform: scale(1.1); }
    .icon-btn:active { transform: scale(0.95); }
    .icon-btn.off { opacity: 0.5; background: rgba(0,0,0,0.3); }

    .stat-box {
        background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(8px);
        padding: 8px 20px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.4);
        color: white; box-shadow: 0 4px 15px rgba(0,0,0,0.3); text-align: center;
    }
    .stat-label { font-size: 11px; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; color: #e0f2fe; }
    .stat-value { font-size: 24px; font-weight: 900; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }

    .oxygen-container {
        background: rgba(15, 23, 42, 0.6); backdrop-filter: blur(10px);
        padding: 8px 15px; border-radius: 30px; border: 2px solid rgba(56, 189, 248, 0.3);
        display: flex; flex-direction: column; align-items: center;
        box-shadow: 0 4px 15px rgba(0,0,0,0.4); min-width: 180px;
    }
    .oxygen-header {
        display: flex; justify-content: space-between; width: 100%; margin-bottom: 4px;
        font-size: 12px; font-weight: 800; color: #bae6fd; text-transform: uppercase; letter-spacing: 1px;
    }
    .oxygen-track { width: 100%; height: 14px; background: #0f172a; border-radius: 10px; overflow: hidden; border: 1px solid #1e293b; position: relative; }
    .oxygen-fill {
        height: 100%; background: linear-gradient(90deg, #0ea5e9, #38bdf8, #7dd3fc);
        width: 100%; transition: width 1s linear, background 0.3s;
        box-shadow: 0 0 10px rgba(14, 165, 233, 0.5); position: relative;
    }
    .oxygen-fill::after {
        content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background-image: radial-gradient(rgba(255,255,255,0.4) 1px, transparent 1px);
        background-size: 10px 10px; opacity: 0.5;
    }
    .oxygen-fill.critical { background: linear-gradient(90deg, #991b1b, #ef4444); box-shadow: 0 0 15px rgba(239, 68, 68, 0.6); animation: pulseRed 0.5s infinite alternate; }
    @keyframes pulseRed { from { filter: brightness(1); } to { filter: brightness(1.3); } }

    /* SIDE PANEL */
    .headlines-panel {
        width: 500px; flex-shrink: 0; background: #f1f5f9; padding: 0;
        display: flex; flex-direction: column; position: relative; z-index: 20;
        box-shadow: -5px 0 15px rgba(0,0,0,0.2);
    }
    .news-header { background: #f1f5f9; padding: 20px 20px 10px 20px; text-align: center; border-bottom: 2px solid #e2e8f0; flex-shrink: 0; }
    .news-title { color: #0f766e; font-size: 28px; font-weight: 900; text-transform: uppercase; display: flex; align-items: center; justify-content: center; gap: 10px; margin: 0; }
    .news-icon { font-size: 28px; color: #64748b; }
    .tablet-screen { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px; }
    .tablet-screen::-webkit-scrollbar { width: 8px; }
    .tablet-screen::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
    .tablet-screen::-webkit-scrollbar-track { background: #f1f5f9; }
    .headline-item {
        background: white; border-radius: 10px; padding: 15px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05), 0 1px 2px rgba(0,0,0,0.1);
        display: flex; flex-direction: column; transition: transform 0.2s, box-shadow 0.2s;
        border: 1px solid transparent;
    }
    .headline-item.completed { border: 1px solid #f59e0b; background: #fffbeb; }
    .headline-content-row { display: flex; align-items: flex-start; gap: 15px; }
    .headline-label {
        background: #0ea5e9; color: white; font-weight: 900; font-size: 20px; width: 36px; height: 36px;
        display: flex; align-items: center; justify-content: center; border-radius: 8px; flex-shrink: 0; margin-top: 2px;
    }
    .headline-item.completed .headline-label { background: #f59e0b; }
    .headline-text { color: #1e293b; font-size: 20px; font-weight: 600; line-height: 1.4; flex: 1; }
    .keyword { color: inherit; border-radius: 3px; transition: all 0.5s; display: inline; }
    .keyword.revealed { color: #d97706; background: rgba(253, 230, 138, 0.5); font-weight: 800; padding: 0 4px; }
    .progress-container { height: 8px; background: #f1f5f9; border-radius: 4px; overflow: hidden; margin-top: 15px; width: 100%; }
    .progress-bar { height: 100%; background: #cbd5e1; width: 0%; transition: width 0.5s; }
    .headline-item.completed .progress-bar { background: #f59e0b; }
    .headline-item:not(.completed) .progress-bar { background: #0ea5e9; }

    /* OVERLAYS & SUMMARY */
    .overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(15, 23, 42, 0.95); display: flex; flex-direction: column;
        justify-content: center; align-items: center; color: white; z-index: 100; backdrop-filter: blur(10px);
    }
    .final-summary-box {
        background: #fff; width: 90%; max-width: 1000px; padding: 25px 30px;
        border-radius: 20px; box-shadow: 0 20px 50px rgba(0,0,0,0.6); margin: 10px 0;
        color: #1e293b; text-align: left; display: flex; flex-direction: column; justify-content: center;
    }
    .final-row { display: flex; align-items: center; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #e2e8f0; }
    .final-row:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .final-label {
        background: #0f766e; color: white; font-size: 20px; font-weight: 900;
        width: 36px; height: 36px; border-radius: 8px; display: flex; justify-content: center;
        align-items: center; margin-right: 15px; flex-shrink: 0;
    }
    .final-text { font-size: 20px; line-height: 1.3; font-weight: 600; color: #334155; }
    .final-keyword { color: #d97706; font-weight: 900; background: #fef3c7; padding: 0 6px; border-radius: 4px; border-bottom: 2px solid #fcd34d; }
    .final-keyword-missing { color: #94a3b8; background: transparent; border-bottom: 2px dashed #cbd5e1; padding: 0 2px; font-weight: normal; }
    .btn-start {
        padding: 12px 50px; font-size: 22px; background: linear-gradient(to bottom, #f59e0b, #d97706);
        border: none; border-radius: 50px; color: white; font-weight: 900; cursor: pointer;
        margin-top: 20px; box-shadow: 0 0 20px rgba(245, 158, 11, 0.5); transition: all 0.2s;
        text-transform: uppercase; letter-spacing: 2px;
    }
    .btn-start:hover { transform: scale(1.05); box-shadow: 0 0 40px rgba(245, 158, 11, 0.7); }
    .btn-start:active { transform: scale(0.95); }

    /* FLYING KEYWORD STYLE */
    .flying-keyword {
        position: absolute;
        color: #1e40af;
        background: #ffffff;
        padding: 10px 20px;
        border-radius: 15px;
        font-weight: 900;
        font-size: 32px;
        border: 3px solid #f59e0b;
        box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        pointer-events: none;
        z-index: 9999;
        transform-origin: center;
        transition: top 2.5s cubic-bezier(0.25, 1, 0.5, 1), left 2.5s cubic-bezier(0.25, 1, 0.5, 1), transform 2.5s ease, opacity 2.5s ease;
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
    }

    .floating-text {
        position: absolute; font-weight: 900; pointer-events: none;
        animation: floatUp 1.2s forwards; z-index: 50; text-shadow: 2px 2px 0 #000;
        font-size: 24px; white-space: nowrap;
    }
    @keyframes floatUp {
        0% { opacity: 0; transform: translateY(10px) scale(0.8); }
        20% { opacity: 1; transform: translateY(0) scale(1.2); }
        100% { opacity: 0; transform: translateY(-60px) scale(1); }
    }

    @media (max-width: 1024px) { .headlines-panel { width: 400px; } .headline-text, .final-text { font-size: 18px; } }
    @media (max-width: 900px) {
        .main-container { flex-direction: column; } .headlines-panel { width: 100%; max-width: 100%; height: 40vh; border-top: 4px solid #0f172a; }
        .game-area { height: 60vh; border-right: none; } .final-text { font-size: 16px; } .final-summary-box { width: 95%; padding: 15px; }
    }
</style>
</head>
<body>

<div class="main-container" id="mainContainer">
    <div class="game-area" id="gameArea">
        <canvas id="gameCanvas"></canvas>
        <div class="game-header">
            <div class="control-group">
                <button class="icon-btn" id="fsBtn" title="Fullscreen" onclick="toggleFullscreen()">â›¶</button>
                <button class="icon-btn" id="musicBtn" title="Toggle Music" onclick="AudioSys.toggleMusic()">ðŸŽµ</button>
            </div>
            <div class="stat-group">
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="scoreDisplay">0</div>
                </div>
                <div class="oxygen-container">
                    <div class="oxygen-header">
                        <span>Oxygen Level</span>
                        <span id="oxygenText">100%</span>
                    </div>
                    <div class="oxygen-track">
                        <div class="oxygen-fill" id="oxygenBar"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="startScreen" class="overlay">
            <h1 style="font-size: 60px; color: #fcd34d; text-shadow: 0 0 30px rgba(251, 191, 36, 0.6); margin-bottom: 10px; text-align:center;">TURTLE RESCUE<br><span style="font-size: 36px; color:white;">Con Dao Mission</span></h1>
            <div style="margin: 20px 0; text-align: left; background: rgba(255,255,255,0.05); padding: 30px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); max-width: 80%;">
                <p style="font-size: 28px; margin: 20px 0; color: #fcd34d; font-weight: 900; text-transform: uppercase; line-height: 1.4;">
                    ðŸ¥š GOAL: CATCH EGGS TO COLLECT KEYWORDS
                </p>
                <p style="font-size: 28px; margin: 20px 0; color: #4ade80; font-weight: 900; text-transform: uppercase; line-height: 1.4;">
                    ðŸŽ® CONTROLS: PRESS SPACE OR CLICK TO DROP HOOK
                </p>
            </div>
            <button class="btn-start" onclick="game.startWithFullscreen()">START RESCUE</button>
        </div>

        <div id="endScreen" class="overlay" style="display: none;">
            <h1 id="endTitle" style="font-size: 42px; margin-bottom: 5px; margin-top: 0;">MISSION OVER</h1>
            <p id="endMessage" style="font-size: 24px; color: #fcd34d; font-weight: bold; margin-top:0; margin-bottom: 10px;">Score: 0</p>
            <div class="final-summary-box" id="finalSummaryList"></div>
            <button class="btn-start" onclick="game.start()">PLAY AGAIN</button>
            <button class="btn-start" onclick="window.location.href='index.html'" style="margin-left:12px;">HOME</button>
        </div>
    </div>

    <div class="headlines-panel" id="headlinesPanelContainer">
        <div class="news-header">
            <h2 class="news-title"><span class="news-icon">ðŸ“°</span> WILDLIFE NEWS</h2>
        </div>
        <div class="tablet-screen" id="headlinesPanel"></div>
    </div>

    <div class="copyright-footer">Teacher Nguyen Thi Thao Uyen - Yersin Primary, Secondary & High School Dalat</div>
</div>

<script>
function toggleFullscreen() {
    const elem = document.documentElement;
    const container = document.getElementById('mainContainer');
    if (!document.fullscreenElement) {
        if (elem.requestFullscreen) elem.requestFullscreen().catch(err => container.classList.add('fullscreen-fallback'));
        else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
        else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        else container.classList.add('fullscreen-fallback');
    } else {
        if (document.exitFullscreen) document.exitFullscreen().catch(err => console.warn(err));
        container.classList.remove('fullscreen-fallback');
    }
}
document.addEventListener('fullscreenchange', () => { if (!document.fullscreenElement) document.getElementById('mainContainer').classList.remove('fullscreen-fallback'); });

const CONFIG = {
    GAME_TIME: 180, 
    HEADLINES: [
        { id: 'A', text: "Plans to {help} {coral reefs} {recover}" },
        { id: 'B', text: "{Sea turtle} {protection} efforts supported by {hundreds of volunteers}" },
        { id: 'C', text: "The {effect} of {diving} activities on {coral reefs}" },
        { id: 'D', text: "{Wildlife art exhibition} to raise public {awareness} and {funds}" },
        { id: 'E', text: "{Young wildlife artists} to {hold exhibition} of vulnerable species" }
    ]
};

const AudioSys = {
    ctx: null, masterGain: null, musicEnabled: true, bgmOscillators: [], nextNoteTime: 0, currentNoteIndex: 0, bgmTimer: null, bgmRunning: false,
    melody: [ [261.63, 2], [329.63, 2], [392.00, 2], [523.25, 2], [440.00, 2], [392.00, 2], [329.63, 4], [349.23, 2], [349.23, 2], [329.63, 2], [329.63, 2], [293.66, 2], [293.66, 2], [261.63, 4], [261.63, 2], [392.00, 2], [523.25, 2], [392.00, 2], [440.00, 2], [523.25, 2], [392.00, 4] ],
    tempo: 140,
    init() {
        if (!this.ctx) {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.masterGain.gain.value = 0.3;
        }
    },
    toggleMusic() {
        this.musicEnabled = !this.musicEnabled;
        const btn = document.getElementById('musicBtn');
        if (this.musicEnabled) { btn.classList.remove('off'); if (this.ctx && this.ctx.state === 'running') this.startBGM(); } 
        else { btn.classList.add('off'); this.stopBGM(); }
    },
    startBGM() {
        if (!this.musicEnabled || this.bgmRunning) return;
        this.init(); if (this.ctx.state === 'suspended') this.ctx.resume();
        this.bgmRunning = true; this.nextNoteTime = this.ctx.currentTime + 0.1; this.currentNoteIndex = 0; this.scheduler();
    },
    stopBGM() { this.bgmRunning = false; clearTimeout(this.bgmTimer); },
    scheduler() {
        if (!this.bgmRunning) return;
        while (this.nextNoteTime < this.ctx.currentTime + 0.1) { this.playMelodyNote(this.nextNoteTime); this.advanceNote(); }
        this.bgmTimer = setTimeout(() => this.scheduler(), 25);
    },
    advanceNote() {
        const secondsPerBeat = 60.0 / this.tempo;
        const noteInfo = this.melody[this.currentNoteIndex];
        const duration = (noteInfo[1] * 0.25) * secondsPerBeat; 
        this.nextNoteTime += duration;
        this.currentNoteIndex++;
        if (this.currentNoteIndex >= this.melody.length) this.currentNoteIndex = 0;
    },
    playMelodyNote(time) {
        if (!this.musicEnabled) return;
        const noteInfo = this.melody[this.currentNoteIndex];
        const freq = noteInfo[0];
        const duration16th = noteInfo[1];
        const secondsPerBeat = 60.0 / this.tempo;
        const length = (duration16th * 0.25) * secondsPerBeat;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.type = 'triangle'; osc.frequency.value = freq;
        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 1000; 
        gain.gain.setValueAtTime(0, time); gain.gain.linearRampToValueAtTime(0.15, time + 0.05); gain.gain.exponentialRampToValueAtTime(0.01, time + length - 0.05);
        osc.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
        osc.start(time); osc.stop(time + length);
        const delay = this.ctx.createDelay(); delay.delayTime.value = 0.2; const delayGain = this.ctx.createGain(); delayGain.gain.value = 0.2;
        gain.connect(delay); delay.connect(delayGain); delayGain.connect(this.masterGain);
    },
    playTone(freq, type, duration, vol=0.1) {
        if (!this.ctx) this.init(); if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + duration);
    },
    playThrow() { this.playTone(600, 'triangle', 0.2, 0.15); },
    playCatchEgg() { this.playTone(523.25, 'sine', 0.1, 0.2); setTimeout(() => this.playTone(659.25, 'sine', 0.2, 0.2), 100); },
    playSplash() {
        if (!this.ctx) this.init(); if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.type = 'triangle'; osc.frequency.setValueAtTime(300, this.ctx.currentTime); osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
        osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + 0.3);
    },
    playExplosion() { 
        if (!this.ctx) this.init(); if (this.ctx.state === 'suspended') this.ctx.resume();
        const bufferSize = this.ctx.sampleRate * 0.5; const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource(); noise.buffer = buffer; const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        noise.connect(gain); gain.connect(this.ctx.destination); noise.start();
    },
    playWin() { this.stopBGM(); [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => { setTimeout(() => this.playTone(f, 'square', 0.4, 0.1), i*120); }); }
};

class HeadlineSystem {
    constructor() { this.panel = document.getElementById('headlinesPanel'); this.data = []; this.totalKeywords = 0; this.unlockedCount = 0; }
    init() {
        this.panel.innerHTML = ''; this.data = []; this.totalKeywords = 0; this.unlockedCount = 0;
        CONFIG.HEADLINES.forEach(h => {
            const parts = h.text.split(/\{([^}]+)\}/g); let html = ''; let keywordIds = [];
            parts.forEach((part, i) => {
                if (i % 2 === 1) { const kid = `kw-${h.id}-${i}`; html += `<span class="keyword" id="${kid}">${part}</span>`; keywordIds.push(kid); this.totalKeywords++; } else { html += part; }
            });
            const el = document.createElement('div'); el.className = 'headline-item'; el.id = `card-${h.id}`;
            el.innerHTML = `<div class="headline-content-row"><div class="headline-label">${h.id}</div><div class="headline-text">${html}</div></div><div class="progress-container"><div class="progress-bar" id="bar-${h.id}"></div></div>`;
            this.panel.appendChild(el); this.data.push({ id: h.id, keywords: keywordIds, unlocked: 0 });
        });
    }
    getTargetKeywordId(letter) {
        const item = this.data.find(d => d.id === letter); if (!item) return null;
        for (let kid of item.keywords) {
            const el = document.getElementById(kid);
            if (!el.classList.contains('revealed')) {
                return { id: kid, text: el.innerText, item: item };
            }
        }
        return null;
    }
    revealKeyword(kid) {
        const el = document.getElementById(kid);
        if (el && !el.classList.contains('revealed')) {
            el.classList.add('revealed');
            const hId = kid.split('-')[1];
            const item = this.data.find(d => d.id === hId);
            if(item) {
                item.unlocked++; this.unlockedCount++;
                const pct = (item.unlocked / item.keywords.length) * 100;
                document.getElementById(`bar-${hId}`).style.width = `${pct}%`;
                if (item.unlocked === item.keywords.length) {
                    document.getElementById(`card-${hId}`).classList.add('completed');
                    return 'COMPLETE';
                }
            }
            return 'UNLOCKED';
        }
        return false;
    }
    isFullWin() { return this.unlockedCount === this.totalKeywords; }
    getFinalSummary(isWin) {
        let html = '';
        this.data.forEach(item => {
            const originalConfig = CONFIG.HEADLINES.find(h => h.id === item.id); const parts = originalConfig.text.split(/\{([^}]+)\}/g);
            let rowHtml = ''; let keywordCounter = 0;
            parts.forEach((part, i) => {
                if (i % 2 === 1) { keywordCounter++; const isUnlocked = isWin || (keywordCounter <= item.unlocked);
                    if (isUnlocked) rowHtml += `<span class="final-keyword">${part}</span>`; else rowHtml += `<span class="final-keyword-missing">${part}</span>`;
                } else rowHtml += part; 
            });
            html += `<div class="final-row"><div class="final-label">${item.id}</div><div class="final-text">${rowHtml}</div></div>`;
        });
        return html;
    }
}

class Airplane {
    constructor(width, height) {
        this.width = width;
        this.y = height * 0.15 + Math.random() * (height * 0.1); // Sky area
        this.x = -300; // Start off-screen left
        this.speed = 0.8; 
        this.text = "HoÃ ng Sa, TrÆ°á»ng Sa is belong to Viá»‡t Nam.";
    }
    update() {
        this.x += this.speed;
    }
    isOffScreen() {
        return this.x > this.width + 800; 
    }
    draw(ctx) {
        Visuals.drawAirplane(ctx, this.x, this.y, this.text);
    }
}

class StudentBoat {
    constructor(width, height) {
        this.gameW = width; this.y = height * 0.35 - 15 + (Math.random() * 20); 
        this.x = Math.random() < 0.5 ? -100 : width + 100; this.dir = this.x < 0 ? 1 : -1;
        this.speed = 0.15 + Math.random() * 0.2; this.message = null; this.messageTimer = 0;
        this.messages = ["Go Yersin Students!", "Save the turtle eggs!", "Yersin School rocks!", "Protect sea turtles!", "Yersin Pride!", "You can do it!", "For the baby turtles!", "Great job Yersin!"];
    }
    update() {
        this.x += this.speed * this.dir;
        if (this.messageTimer <= 0) { if (Math.random() < 0.005) { this.message = this.messages[Math.floor(Math.random() * this.messages.length)]; this.messageTimer = 180; } } 
        else { this.messageTimer--; if (this.messageTimer <= 0) this.message = null; }
    }
    isOffScreen() { return (this.dir === 1 && this.x > this.gameW + 150) || (this.dir === -1 && this.x < -150); }
    draw(ctx, frame) { Visuals.drawStudentBoat(ctx, this.x, this.y, frame, this.dir, this.message); }
}

const Visuals = {
    drawAirplane(ctx, x, y, text) {
        ctx.save();
        ctx.translate(x, y);
        
        // Plane Body
        ctx.fillStyle = "#e2e8f0"; // White/Grey
        ctx.beginPath();
        ctx.ellipse(0, 0, 30, 8, 0, 0, Math.PI*2); // Fuselage
        ctx.fill();
        
        // Wings
        ctx.fillStyle = "#94a3b8";
        ctx.beginPath();
        ctx.moveTo(5, 0); ctx.lineTo(-5, -20); ctx.lineTo(-15, 0); // Top wing
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(5, 0); ctx.lineTo(-5, 15); ctx.lineTo(-15, 0); // Bottom wing
        ctx.fill();
        
        // Tail
        ctx.beginPath();
        ctx.moveTo(-25, 0); ctx.lineTo(-32, -10); ctx.lineTo(-32, 0);
        ctx.fill();
        
        // Propeller
        ctx.fillStyle = "#334155";
        ctx.fillRect(28, -5, 2, 10);

        // Banner String
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-30, 0);
        ctx.lineTo(-60, 0);
        ctx.stroke();

        // Banner
        ctx.fillStyle = "#ef4444"; // Red Banner (Vietnam Flag Color)
        // Calculate text width
        ctx.font = "bold 14px Arial";
        const textMetrics = ctx.measureText(text);
        const bannerW = textMetrics.width + 20;
        
        ctx.fillRect(-60 - bannerW, -12, bannerW, 24);
        
        // Banner Border
        ctx.strokeStyle = "#f59e0b"; // Yellow/Gold Border
        ctx.lineWidth = 2;
        ctx.strokeRect(-60 - bannerW, -12, bannerW, 24);
        
        // Text
        ctx.fillStyle = "#f59e0b"; // Yellow Text
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        ctx.fillText(text, -70, 0);

        ctx.restore();
    },
    drawLighthouse(ctx, width, height, frame) {
        const lx = width * 0.85; // Right side
        const ly = height * 0.35; // Horizon level
        
        ctx.save();
        ctx.translate(lx, ly);

        // Light Beam - SLOWED DOWN (0.005 instead of 0.02)
        const angle = frame * 0.005;
        ctx.save();
        ctx.translate(0, -60); // Light source
        ctx.rotate(angle);
        const beamGrad = ctx.createLinearGradient(0, 0, 300, 0);
        beamGrad.addColorStop(0, "rgba(255, 255, 200, 0.3)"); // Slightly dimmer
        beamGrad.addColorStop(1, "rgba(255, 255, 200, 0)");
        ctx.fillStyle = beamGrad;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(300, -40);
        ctx.lineTo(300, 40);
        ctx.fill();
        // Second beam opposite
        ctx.rotate(Math.PI);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(300, -40);
        ctx.lineTo(300, 40);
        ctx.fill();
        ctx.restore();

        // Tower
        ctx.fillStyle = "#e2e8f0"; // White base
        ctx.beginPath();
        ctx.moveTo(-15, 0); ctx.lineTo(15, 0); ctx.lineTo(10, -60); ctx.lineTo(-10, -60);
        ctx.fill();
        
        // Red stripes
        ctx.fillStyle = "#ef4444";
        ctx.beginPath();
        ctx.moveTo(-14, -10); ctx.lineTo(14, -10); ctx.lineTo(13, -20); ctx.lineTo(-13, -20);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-12, -30); ctx.lineTo(12, -30); ctx.lineTo(11, -40); ctx.lineTo(-11, -40);
        ctx.fill();

        // Top housing
        ctx.fillStyle = "#334155";
        ctx.fillRect(-12, -65, 24, 5); // Gallery
        ctx.fillStyle = "#fcd34d"; // Light room (lit)
        ctx.fillRect(-8, -75, 16, 10);
        ctx.fillStyle = "#1e293b"; // Roof
        ctx.beginPath(); ctx.moveTo(-10, -75); ctx.lineTo(10, -75); ctx.lineTo(0, -85); ctx.fill();

        ctx.restore();
    },
    drawTrash(ctx, x, y, angle) {
        ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
        ctx.fillStyle = "rgba(200, 230, 255, 0.7)"; ctx.strokeStyle = "rgba(255, 255, 255, 0.8)"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.rect(-10, -15, 20, 30); ctx.fill(); ctx.stroke(); 
        ctx.fillStyle = "#0284c7"; ctx.fillRect(-5, -20, 10, 5); 
        ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.beginPath(); ctx.moveTo(-5, -10); ctx.lineTo(5, -5); ctx.stroke(); 
        ctx.restore();
    },
    drawDecoration(ctx, type, x, y, scale, frame) {
        ctx.save(); ctx.translate(x, y); ctx.scale(scale, scale);
        if (type === 'shell') {
            ctx.fillStyle = "#fbcfe8"; ctx.beginPath(); ctx.arc(0, 0, 12, Math.PI, 0); ctx.fill(); 
            ctx.fillStyle = "#f9a8d4"; ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI); ctx.fill(); 
            const glow = Math.abs(Math.sin(frame * 0.05 + x));
            ctx.fillStyle = `rgba(255, 255, 255, ${0.6 + glow * 0.4})`; ctx.beginPath(); ctx.arc(0, -2, 5, 0, Math.PI*2); ctx.fill();
            if (Math.floor(frame/10 + x) % 20 === 0) { ctx.fillStyle = "white"; ctx.font = "12px Arial"; ctx.fillText("âœ¨", 8, -8); }
        } else if (type === 'chest') {
            ctx.fillStyle = "#854d0e"; ctx.fillRect(-15, -10, 30, 20);
            ctx.fillStyle = "#fbbf24"; ctx.fillRect(-15, -10, 30, 4); ctx.fillRect(-15, 6, 30, 4); ctx.fillRect(-3, -10, 6, 20);
            ctx.beginPath(); ctx.arc(0, -10, 15, Math.PI, 0); ctx.fill();
            if (Math.floor(frame/15 + x) % 25 === 0) { ctx.fillStyle = "#fef08a"; ctx.font = "14px Arial"; ctx.fillText("âœ¨", -10 + Math.random()*20, -20); }
        }
        ctx.restore();
    },
    drawBadge(ctx, frame, text) {
        ctx.save(); const badgeX = 180; const badgeY = 120;
        const scale = 1 + Math.sin(frame * 0.2) * 0.1; 
        ctx.translate(badgeX, badgeY); ctx.scale(scale, scale);
        ctx.shadowColor = "#4ade80"; ctx.shadowBlur = 25;
        ctx.fillStyle = "#fcd34d"; ctx.beginPath();
        for (let i = 0; i < 12; i++) { const angle = (i / 12) * Math.PI * 2; const r = i % 2 === 0 ? 40 : 25; ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r); }
        ctx.closePath(); ctx.fill();
        const grad = ctx.createRadialGradient(0,0,5,0,0,30); grad.addColorStop(0, "#86efac"); grad.addColorStop(1, "#22c55e");
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, 28, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.stroke();
        ctx.shadowBlur = 0; ctx.font = "bold 24px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = "white"; ctx.fillText("â™»ï¸", 0, -2);
        ctx.font = "900 10px Arial"; ctx.fillText(text, 0, 18);
        ctx.restore();
    },
    drawMotherTurtle(ctx, x, y, frame, reaction, dir, message) {
        ctx.save(); ctx.translate(x, y); ctx.scale(dir, 1); 
        let sway = Math.sin(frame * 0.02) * 2; let legMove = Math.sin(frame * 0.05) * 3; let yOffset = 0;
        if (reaction === 'happy') { sway = Math.sin(frame * 0.2) * 3; yOffset = -Math.abs(Math.sin(frame * 0.1) * 10); legMove = Math.sin(frame * 0.3) * 5; }
        const drawY = yOffset;
        const shellGrad = ctx.createRadialGradient(-5, drawY - 10, 5, 0, drawY, 35); shellGrad.addColorStop(0, '#10b981'); shellGrad.addColorStop(1, '#064e3b');
        ctx.fillStyle = shellGrad; ctx.beginPath(); ctx.ellipse(0, drawY, 35, 25, 0, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#064e3b'; ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = '#10b981'; ctx.beginPath(); ctx.ellipse(35 + sway, drawY - 5, 12, 10, 0, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
        if (reaction === 'happy') { ctx.beginPath(); ctx.moveTo(34 + sway, drawY - 7); ctx.lineTo(38 + sway, drawY - 10); ctx.lineTo(42 + sway, drawY - 7); ctx.stroke(); }
        else { ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(38 + sway, drawY - 7, 2, 0, Math.PI*2); ctx.fill(); }
        ctx.fillStyle = '#059669';
        ctx.beginPath(); ctx.ellipse(15, drawY + 20 + legMove, 8, 12, 0.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(-15, drawY + 20 - legMove, 8, 12, -0.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(-30, drawY + 5, 6, 10, -1, 0, Math.PI*2); ctx.fill();
        if (message) {
            ctx.save(); ctx.scale(dir, 1);
            const bx = dir === 1 ? 40 : -40; const by = -60;
            ctx.fillStyle = 'white'; ctx.beginPath(); ctx.roundRect(bx - 50, by - 15, 100, 30, 10); ctx.fill();
            ctx.beginPath(); ctx.moveTo(dir === 1 ? bx - 10 : bx + 10, by + 15); ctx.lineTo(dir === 1 ? bx - 20 : bx + 20, by + 25); ctx.lineTo(dir === 1 ? bx : bx, by + 15); ctx.fill();
            ctx.fillStyle = '#333'; ctx.font = "bold 14px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(message, bx, by);
            ctx.restore();
        }
        ctx.restore();
    },
    drawFish(ctx, x, y, frame, dir) {
        ctx.save(); ctx.translate(x, y); if(dir < 0) ctx.scale(-1, 1);
        const tail = Math.sin(frame * 0.2) * 5;
        ctx.fillStyle = "#f472b6"; ctx.beginPath(); ctx.ellipse(0, 0, 15, 10, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#ec4899"; ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(-20, -8 + tail); ctx.lineTo(-20, 8 + tail); ctx.fill();
        ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(8, -3, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(9, -3, 1, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    },
    drawSeagull(ctx, x, y, frame) {
        ctx.save(); ctx.translate(x, y); ctx.beginPath();
        const wingY = Math.sin(frame * 0.15) * 8;
        ctx.moveTo(-15, -wingY); ctx.quadraticCurveTo(0, 5, 15, -wingY);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.stroke();
        ctx.restore();
    },
    drawStudentBoat(ctx, x, y, frame, dir, message) {
        ctx.save(); ctx.translate(x, y); ctx.scale(dir, 1); const scale = 0.9; ctx.scale(scale, scale);
        const bob = Math.sin(frame * 0.1 + x) * 2;
        ctx.save(); ctx.shadowColor = "rgba(0,0,0,0.2)"; ctx.shadowBlur = 5; ctx.shadowOffsetY = 5;
        const flagWave = Math.sin(frame * 0.2 + x) * 3;
        ctx.save(); ctx.translate(-38, -5 + bob); ctx.rotate(Math.sin(frame * 0.1) * 0.1); 
        ctx.strokeStyle = "#cbd5e1"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -35); ctx.stroke();
        ctx.fillStyle = "#f59e0b"; ctx.beginPath(); ctx.moveTo(0, -35); ctx.quadraticCurveTo(15, -35 + flagWave, 25, -28 + flagWave); ctx.lineTo(25, -18 + flagWave); ctx.quadraticCurveTo(15, -25 + flagWave, 0, -20); ctx.fill();
        ctx.save(); ctx.translate(10, -26 + flagWave); ctx.scale(dir, 1); ctx.fillStyle = "#fff"; ctx.font = "900 6px Arial"; ctx.textAlign = "center"; ctx.fillText("YERSIN", 0, 3); ctx.restore(); ctx.restore();
        const boatGrad = ctx.createLinearGradient(0, -10, 0, 20); boatGrad.addColorStop(0, '#fdba74'); boatGrad.addColorStop(1, '#ea580c');
        ctx.fillStyle = boatGrad; ctx.beginPath(); ctx.moveTo(-38, -5 + bob); ctx.lineTo(25, -5 + bob); ctx.quadraticCurveTo(40, -5 + bob, 45, -15 + bob); ctx.lineTo(42, 10 + bob); ctx.quadraticCurveTo(20, 25 + bob, -35, 20 + bob); ctx.lineTo(-38, -5 + bob); ctx.closePath(); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-36, 8 + bob); ctx.lineTo(35, 8 + bob); ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.beginPath(); ctx.moveTo(10, -5 + bob); ctx.lineTo(18, -12 + bob); ctx.lineTo(25, -5 + bob); ctx.fill();
        ctx.fillStyle = "#334155"; ctx.fillRect(-42, -5 + bob, 6, 15);
        ctx.strokeStyle = "#c2410c"; ctx.lineWidth = 1.5; ctx.stroke(); ctx.restore();
        const bodyY = -25 + bob;
        ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.ellipse(0, bodyY + 10, 13, 15, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#f97316"; ctx.beginPath(); ctx.moveTo(-6, bodyY); ctx.quadraticCurveTo(0, bodyY + 10, 6, bodyY); ctx.lineTo(0, bodyY + 4); ctx.fill();
        ctx.fillStyle = "#fcd34d"; ctx.beginPath(); ctx.arc(0, bodyY - 6, 10, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#ea580c"; ctx.beginPath(); ctx.arc(0, bodyY - 9, 10.5, Math.PI, 0); ctx.fill();
        ctx.fillStyle = "#f97316"; ctx.beginPath(); ctx.rect(0, bodyY - 9, 14, 3); ctx.fill();
        ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(-3, bodyY - 5, 1.5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(4, bodyY - 5, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#c2410c"; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, bodyY - 2, 3, 0, Math.PI); ctx.stroke();
        const armWave = Math.sin(frame * 0.2) * 0.5;
        ctx.strokeStyle = "#fcd34d"; ctx.lineWidth = 4; ctx.lineCap = "round";
        ctx.beginPath(); ctx.moveTo(8, bodyY + 4); ctx.lineTo(16, bodyY - 6 + Math.sin(frame * 0.2) * 5); ctx.stroke();
        if (message) {
            ctx.save(); ctx.scale(1/scale, 1/scale); ctx.scale(dir, 1); 
            const bx = 0; const by = (-75 + bob) * scale;
            ctx.font = "bold 14px Arial"; const textMetrics = ctx.measureText(message);
            const textWidth = textMetrics.width; const padding = 8;
            ctx.fillStyle = "rgba(255, 255, 255, 0.95)"; ctx.strokeStyle = "#333"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.roundRect(bx - textWidth/2 - padding, by - 15 - padding, textWidth + padding*2, 30 + padding, 8); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(bx, by + 15); ctx.lineTo(bx - 8 * dir, by + 24); ctx.lineTo(bx + 8 * dir, by + 15); ctx.fill(); ctx.stroke();
            ctx.fillStyle = "#ea580c"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(message, bx, by);
            ctx.restore();
        }
        ctx.restore();
    },
    drawArchaeologist(ctx, x, y, frame, reaction, isLongIdle) {
        let bob = Math.sin(frame * 0.02) * 2; let shakeX = 0;
        if (reaction === 'panic') { shakeX = (Math.random() - 0.5) * 3; bob = Math.sin(frame * 0.2) * 3; }
        const cX = x + shakeX; const cY = y + bob;
        const flagWave = Math.sin(frame * 0.15) * 5;
        ctx.save(); ctx.translate(cX - 65, cY - 25); ctx.rotate(Math.sin(frame * 0.05) * 0.05); 
        ctx.strokeStyle = "#94a3b8"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(0, -50); ctx.stroke();
        const flagGrad = ctx.createLinearGradient(0, -50, 40, -30); flagGrad.addColorStop(0, '#f59e0b'); flagGrad.addColorStop(1, '#fcd34d');
        ctx.fillStyle = flagGrad; ctx.beginPath(); ctx.moveTo(0, -50); ctx.quadraticCurveTo(20, -50 + flagWave, 40, -40 + flagWave);
        ctx.lineTo(40, -20 + flagWave); ctx.quadraticCurveTo(20, -30 + flagWave, 0, -30); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.font = "900 9px Arial"; ctx.textAlign = "center"; ctx.fillText("YERSIN", 18, -32 + flagWave); ctx.restore();
        ctx.save(); ctx.translate(cX, cY);
        ctx.fillStyle = "rgba(0,0,0,0.2)"; ctx.beginPath(); ctx.ellipse(0, 28, 65, 12, 0, 0, Math.PI*2); ctx.fill();
        const hullGrad = ctx.createLinearGradient(-40, -20, 40, 20); hullGrad.addColorStop(0, '#fb923c'); hullGrad.addColorStop(0.5, '#f97316'); hullGrad.addColorStop(1, '#c2410c');
        ctx.fillStyle = hullGrad; ctx.beginPath(); ctx.moveTo(-70, -5); ctx.lineTo(60, -5); ctx.quadraticCurveTo(80, -5, 85, -15);
        ctx.lineTo(80, 15); ctx.quadraticCurveTo(40, 30, -60, 25); ctx.lineTo(-70, -5); ctx.fill();
        ctx.strokeStyle = "white"; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-68, 8); ctx.lineTo(75, 8); ctx.stroke();
        ctx.fillStyle = "rgba(203, 213, 225, 0.5)"; ctx.beginPath(); ctx.moveTo(30, -5); ctx.lineTo(45, -20); ctx.lineTo(55, -5); ctx.fill();
        ctx.strokeStyle = "#cbd5e1"; ctx.lineWidth = 2; ctx.stroke();
        const seatX = -15; const seatY = -15;
        ctx.fillStyle = "#334155"; ctx.beginPath(); ctx.moveTo(seatX, seatY); ctx.lineTo(seatX + 25, seatY - 5); 
        ctx.lineTo(seatX + 30, seatY + 15); ctx.lineWidth = 9; ctx.strokeStyle = "#334155"; ctx.lineCap = "round"; ctx.stroke();
        ctx.fillStyle = "#f97316"; ctx.beginPath(); ctx.roundRect(seatX - 12, seatY - 38, 28, 38, 6); ctx.fill();
        ctx.fillStyle = "#e2e8f0"; ctx.fillRect(seatX - 12, seatY - 30, 28, 6); ctx.fillRect(seatX - 12, seatY - 15, 28, 6);
        ctx.fillStyle = "#fcd34d"; ctx.beginPath(); ctx.arc(seatX + 2, seatY - 45, 13, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(seatX + 2, seatY - 48, 13, Math.PI, 0); ctx.fill();
        ctx.fillStyle = "#f97316"; ctx.beginPath(); ctx.rect(seatX + 2, seatY - 48, 16, 4); ctx.fill();
        ctx.fillStyle = "#1e293b"; ctx.beginPath(); ctx.roundRect(seatX + 2, seatY - 46, 10, 4, 2); ctx.fill();
        ctx.strokeStyle = "#000"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(seatX + 7, seatY - 46); ctx.lineTo(seatX + 7, seatY - 42); ctx.stroke();
        ctx.strokeStyle = "#fcd34d"; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(seatX + 5, seatY - 30);
        if (reaction === 'panic') { ctx.lineTo(seatX + 15, seatY - 55); ctx.lineTo(seatX + 35, seatY - 60); } 
        else { ctx.lineTo(seatX + 20, seatY - 20); ctx.lineTo(seatX + 40, seatY - 25); }
        ctx.stroke();
        ctx.fillStyle = "#475569"; ctx.beginPath(); ctx.arc(10, 0, 8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#94a3b8"; ctx.beginPath(); ctx.arc(10, 0, 4, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    },
    drawEgg(ctx, x, y, angle, letter) {
        ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
        const eggGrad = ctx.createRadialGradient(-5, -10, 5, 0, 0, 25);
        eggGrad.addColorStop(0, '#ecfccb'); eggGrad.addColorStop(0.5, '#a3e635'); eggGrad.addColorStop(1, '#4d7c0f'); 
        ctx.fillStyle = eggGrad; ctx.beginPath(); ctx.ellipse(0, 0, 20, 26, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(20, 83, 45, 0.6)'; for(let i=0; i<8; i++) { const dx = Math.sin(i * 123) * 12; const dy = Math.cos(i * 321) * 18; ctx.beginPath(); ctx.arc(dx, dy, 1.5, 0, Math.PI*2); ctx.fill(); }
        ctx.fillStyle = "#14532d"; ctx.font = "900 24px 'Arial'"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(letter, 0, 2);
        ctx.fillStyle = "rgba(255,255,255,0.6)"; ctx.beginPath(); ctx.ellipse(-8, -10, 4, 8, -0.3, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    },
    drawBomb(ctx, x, y, angle, frame, isWarning) {
        ctx.save(); let offsetX = 0, offsetY = 0;
        if (isWarning) { offsetX = (Math.random() - 0.5) * 3; offsetY = (Math.random() - 0.5) * 3; ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 20 + Math.sin(frame * 0.5) * 10; } 
        else { ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 5; }
        ctx.translate(x + offsetX, y + offsetY); ctx.rotate(angle);
        const grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 22);
        if (isWarning) { grad.addColorStop(0, '#fca5a5'); grad.addColorStop(1, '#7f1d1d'); } 
        else { grad.addColorStop(0, '#4b5563'); grad.addColorStop(1, '#111827'); }
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, 24, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.2)"; ctx.beginPath(); ctx.arc(-8, -8, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = isWarning ? "#fff" : "#ef4444"; ctx.font = "16px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("â˜ ï¸", 0, 2);
        ctx.strokeStyle = "#b91c1c"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -24); ctx.quadraticCurveTo(5, -35, 10, -30); ctx.stroke();
        if (Math.floor(frame / 5) % 2 === 0) { ctx.fillStyle = "#fef08a"; ctx.beginPath(); ctx.arc(10, -30, 4, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = "#f59e0b"; ctx.beginPath(); ctx.arc(10, -30, 2, 0, Math.PI*2); ctx.fill(); }
        ctx.restore();
    }
};

class Entity {
    constructor(gameW, gameH, type, forcedLetter = null) {
        this.gameW = gameW; this.gameH = gameH; this.type = type; this.caught = false; this.isWarning = false; 
        
        const sandStart = gameH * 0.7;
        
        if (type === 'egg') {
            // Central area for eggs: 25% to 75% width
            this.x = gameW * 0.25 + Math.random() * (gameW * 0.5);
            const letters = ['A', 'B', 'C', 'D', 'E']; 
            this.letter = forcedLetter || letters[Math.floor(Math.random() * letters.length)];
            this.radius = 22; this.weight = 1.5; this.value = 10;
            this.y = sandStart + Math.random() * (gameH - sandStart - 30); 
            this.rotation = (Math.random() - 0.5) * 0.5; 
        } else if (type === 'bomb') {
            // Random x, overridden later in start() for fixed positions
            this.x = Math.random() * gameW;
            this.radius = 24; this.weight = 2.5; this.value = -30;
            const minY = gameH * 0.35 + 50; const maxY = sandStart + 50; 
            this.y = Math.random() * (maxY - minY) + minY;
        } else if (type === 'fish') {
            this.x = Math.random() * gameW;
            this.radius = 20; this.weight = 0.8; this.value = -5;
            this.dir = Math.random() > 0.5 ? 1 : -1; 
            this.speed = (Math.random() * 1 + 0.5) * this.dir;
            const minY = gameH * 0.35 + 50; const maxY = sandStart - 50; 
            this.y = Math.random() * (maxY - minY) + minY;
        } else if (type === 'trash') {
            this.x = Math.random() * (gameW - 100) + 50;
            this.radius = 20; this.weight = 1.0; this.value = 15;
            const minY = gameH * 0.35 + 50; const maxY = sandStart + 20; 
            this.y = Math.random() * (maxY - minY) + minY;
            this.rotation = Math.random() * Math.PI;
        }
    }
    update() {
        if (this.type === 'fish' && !this.caught) {
            this.x += this.speed;
            if (this.x > this.gameW + 50) this.x = -50; if (this.x < -50) this.x = this.gameW + 50;
        }
    }
    draw(ctx, x, y, angle, frame) {
        if (this.type === 'egg') Visuals.drawEgg(ctx, x, y, angle + (this.rotation || 0), this.letter);
        else if (this.type === 'bomb') Visuals.drawBomb(ctx, x, y, angle, frame, this.isWarning);
        else if (this.type === 'fish') { const facingDir = this.caught ? 1 : this.dir; Visuals.drawFish(ctx, x, y, frame, facingDir); }
        else if (this.type === 'trash') { Visuals.drawTrash(ctx, x, y, angle + (this.rotation || 0)); }
    }
}

class Seagull {
    constructor(width, height) { this.x = Math.random() > 0.5 ? -20 : width + 20; this.y = Math.random() * (height * 0.3); this.speed = (Math.random() * 1 + 0.5) * (this.x < 0 ? 1 : -1); this.active = true; }
    update(width) { this.x += this.speed; if ((this.speed > 0 && this.x > width + 50) || (this.speed < 0 && this.x < -50)) this.active = false; }
    draw(ctx, frame) { Visuals.drawSeagull(ctx, this.x, this.y, frame); }
}
class CloudShadow {
    constructor(width, height) { this.x = -300; this.y = Math.random() * (height * 0.5) + height * 0.4; this.w = 200 + Math.random() * 200; this.h = 60 + Math.random() * 40; this.speed = 0.3 + Math.random() * 0.2; this.active = true; }
    update(width) { this.x += this.speed; if (this.x > width + this.w) this.active = false; }
    draw(ctx) { ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; ctx.beginPath(); ctx.ellipse(this.x, this.y, this.w/2, this.h/2, 0, 0, Math.PI*2); ctx.fill(); }
}
class Particle {
    constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.life = 1.0; if (type === 'bubble') { this.vy = - (Math.random() * 1 + 1.5); this.size = Math.random() * 3 + 2; } else { this.vx = (Math.random() - 0.5) * 4; this.vy = - Math.random() * 4 - 2; this.ay = 0.2; this.size = Math.random() * 3 + 1; } }
    update() { if (this.type === 'bubble') { this.y += this.vy; this.x += Math.sin(this.y * 0.05) * 0.5; if(this.y < 200) this.life -= 0.02; } else { this.x += this.vx; this.y += this.vy; this.vy += this.ay; this.life -= 0.03; } }
    draw(ctx) { 
        ctx.globalAlpha = this.life; 
        if (this.type === 'bubble') {
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)"; ctx.strokeStyle = "rgba(255,255,255,0.5)";
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(this.x - this.size*0.3, this.y - this.size*0.3, this.size*0.2, 0, Math.PI*2); ctx.fillStyle = "rgba(255,255,255,0.8)"; ctx.fill();
        } else {
            ctx.fillStyle = "rgba(255, 255, 255, 0.6)"; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1; 
    }
}

class Hook {
    constructor() { this.angle = 0; this.length = 60; this.state = 'IDLE'; this.swingDir = 1; this.item = null; this.originX = 0; this.originY = 90; }
    update(entities, gameW, gameH) {
        this.originX = gameW / 2; this.originY = gameH * 0.35 - 20; 
        if (this.state === 'THROW' || this.state === 'IDLE') {
            const hX = this.originX + Math.sin(this.angle) * (this.state === 'THROW' ? this.length : 60);
            const hY = this.originY + Math.cos(this.angle) * (this.state === 'THROW' ? this.length : 60);
            entities.forEach(e => { if (e.type === 'bomb') { const dist = Math.hypot(hX - e.x, hY - e.y); e.isWarning = (dist < 120); } });
        }
        if (this.state === 'IDLE') { this.angle += 0.005 * this.swingDir; if (this.angle > 1.2 || this.angle < -1.2) this.swingDir *= -1; } 
        else if (this.state === 'THROW') {
            this.length += 12; const hX = this.originX + Math.sin(this.angle) * this.length; const hY = this.originY + Math.cos(this.angle) * this.length;
            if (hY > gameH * 0.35 && hY < gameH * 0.35 + 20) { if (Math.random() < 0.3) game.addSplash(hX, hY); }
            if (this.length > gameH || hX < 0 || hX > gameW) this.state = 'PULL';
            if (!this.item) { 
                for (let e of entities) { 
                    // IGNORE FISH LOGIC
                    if (e.type === 'fish') continue;
                    
                    if (!e.caught) { 
                        if (Math.hypot(hX - e.x, hY - e.y) < 30) { 
                            this.item = e; e.caught = true; this.state = 'PULL'; if (hY > gameH * 0.35) AudioSys.playSplash(); break; 
                        } 
                    } 
                } 
            }
        } else if (this.state === 'PULL') {
            let speed = 15; if (this.item) speed = 15 / this.item.weight; this.length -= speed;
            if (this.length <= 60) { this.length = 60; this.state = 'IDLE'; if (this.item) return this.item; }
        }
        return null;
    }
    draw(ctx, frame, reaction, isIdle) {
        const hX = this.originX + Math.sin(this.angle) * this.length; const hY = this.originY + Math.cos(this.angle) * this.length;
        const boatBob = Math.sin(frame * 0.05) * 3; const drawBaseY = this.originY + boatBob;
        ctx.beginPath(); ctx.moveTo(this.originX, drawBaseY); ctx.lineTo(hX, hY); ctx.strokeStyle = "#334155"; ctx.lineWidth = 3; ctx.stroke();
        ctx.save(); ctx.translate(hX, hY); ctx.rotate(-this.angle);
        ctx.fillStyle = "#64748b"; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#475569"; ctx.lineWidth = 5; ctx.lineCap = "round"; const open = this.item ? 0.2 : 0.5;
        ctx.beginPath(); ctx.arc(0, -5, 16, open, Math.PI - open); ctx.stroke();
        if (this.item) this.item.draw(ctx, 0, 25, this.angle, frame);
        ctx.restore();
        Visuals.drawArchaeologist(ctx, this.originX, this.originY, frame, reaction, isIdle);
    }
}

const game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    headlines: new HeadlineSystem(), hook: new Hook(),
    entities: [], particles: [], seagulls: [], studentBoats: [], decorations: [], airplanes: [],
    state: 'START', score: 0, time: 0, frame: 0, width: 0, height: 0, motherTurtleX: 50, stars: [],
    reactionState: 'none', reactionTimer: 0, lastActionTime: 0, motherTurtleDir: 1, motherTurtleMessage: null, motherTurtleMessageTimer: 0,
    shake: 0, showBadgeTimer: 0, 

    init() {
        this.resize(); window.addEventListener('resize', () => this.resize());
        const trigger = () => { 
            if (this.state === 'PLAYING' && this.hook.state === 'IDLE') { 
                this.hook.state = 'THROW'; AudioSys.playThrow(); this.lastActionTime = Date.now(); 
            }
            if (AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
        };
        window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowDown') trigger(); });
        this.canvas.addEventListener('pointerdown', trigger);
        for(let i=0; i<50; i++) this.stars.push({x: Math.random(), y: Math.random() * 0.35, s: Math.random()});
        // Initialize headlines immediately
        this.headlines.init();
        this.loop = this.loop.bind(this); requestAnimationFrame(this.loop);
    },
    resize() {
        const c = document.getElementById('gameArea'); const newWidth = c.clientWidth; const newHeight = c.clientHeight;
        if (this.width > 0 && this.height > 0) {
            const scaleX = newWidth / this.width; const scaleY = newHeight / this.height;
            this.entities.forEach(e => { e.x *= scaleX; e.y *= scaleY; e.gameW = newWidth; e.gameH = newHeight; });
            this.seagulls.forEach(s => { s.x *= scaleX; s.y *= scaleY; });
            this.airplanes.forEach(a => { a.y = newHeight * 0.15 + Math.random() * (newHeight * 0.1); });
            this.studentBoats.forEach(s => { s.gameW = newWidth; s.y = newHeight * 0.35 - 15 + (Math.random() * 20); });
            // Resize decorations
            this.decorations.forEach(d => { d.x *= scaleX; d.y = newHeight * 0.7 + (d.y - this.height * 0.7) * scaleY; });
        }
        this.width = newWidth; this.height = newHeight; this.canvas.width = this.width; this.canvas.height = this.height;
    },
    addSplash(x, y) { for(let i=0; i<5; i++) this.particles.push(new Particle(x, y, 'splash')); },
    startWithFullscreen() { this.start(); AudioSys.startBGM(); },
    start() {
        document.getElementById('startScreen').style.display = 'none'; document.getElementById('endScreen').style.display = 'none';
        this.headlines.init(); this.state = 'PLAYING'; this.score = 0; this.time = CONFIG.GAME_TIME;
        this.hook.state = 'IDLE'; this.hook.item = null; this.shake = 0; this.showBadgeTimer = 0;
        this.entities = []; this.particles = []; this.motherTurtleX = 50; this.motherTurtleDir = 1;
        this.seagulls = []; this.studentBoats = []; this.airplanes = []; this.lastActionTime = Date.now();
        this.headlines.data.forEach(h => { const count = h.keywords.length; for(let i=0; i<count; i++) this.entities.push(new Entity(this.width, this.height, 'egg', h.id)); });
        
        // --- NEW BOMB LOGIC: EXACTLY 2 FAR APART ---
        const b1 = new Entity(this.width, this.height, 'bomb'); b1.x = this.width * 0.1; this.entities.push(b1); // Left bomb
        const b2 = new Entity(this.width, this.height, 'bomb'); b2.x = this.width * 0.9; this.entities.push(b2); // Right bomb

        for(let i=0; i<5; i++) this.entities.push(new Entity(this.width, this.height, 'fish'));
        for(let i=0; i<4; i++) this.entities.push(new Entity(this.width, this.height, 'trash')); 
        this.studentBoats.push(new StudentBoat(this.width, this.height));
        
        // Generate Decorations
        this.decorations = [];
        const sandStart = this.height * 0.7;
        for(let i=0; i<8; i++) {
            this.decorations.push({ 
                type: 'shell', 
                x: Math.random() * this.width, 
                y: sandStart + Math.random() * (this.height - sandStart - 20),
                scale: 0.5 + Math.random() * 0.5 
            });
        }
        for(let i=0; i<2; i++) {
            this.decorations.push({ 
                type: 'chest', 
                x: Math.random() * this.width, 
                y: sandStart + 10 + Math.random() * (this.height - sandStart - 40),
                scale: 0.8 + Math.random() * 0.4 
            });
        }

        this.updateUI();
        if (this.timerInt) clearInterval(this.timerInt);
        this.timerInt = setInterval(() => {
            if (this.state === 'PLAYING') {
                this.time--; if (this.time <= 0) this.endGame(); this.updateUI();
                if (Math.random() < 0.1) this.particles.push(new Particle(Math.random() * this.width, this.height, 'bubble'));
                
                // SAFETY CHECK: Ensure solvability
                this.ensureSolvability();
            }
        }, 1000);
    },
    ensureSolvability() {
        // Check each incomplete headline
        this.headlines.data.forEach(h => {
            if (h.unlocked < h.keywords.length) {
                // Count how many eggs of this type exist
                const count = this.entities.filter(e => e.type === 'egg' && e.letter === h.id).length;
                // If none, respawn one
                if (count === 0) {
                    const newEgg = new Entity(this.width, this.height, 'egg', h.id);
                    this.entities.push(newEgg);
                }
            }
        });
    },
    endGame() {
        this.state = 'END'; clearInterval(this.timerInt);
        const isWin = this.headlines.isFullWin();
        const summaryHtml = this.headlines.getFinalSummary(isWin);
        document.getElementById('finalSummaryList').innerHTML = summaryHtml;
        document.getElementById('endScreen').style.display = 'flex';
        document.getElementById('endMessage').innerText = `Final Score: ${this.score}`;
        if (isWin) { document.getElementById('endTitle').innerText = "MISSION COMPLETE!"; document.getElementById('endTitle').style.color = "#4ade80"; AudioSys.playWin(); } 
        else { document.getElementById('endTitle').innerText = "TIME UP!"; document.getElementById('endTitle').style.color = "#fbbf24"; }
    },
    spawnFlyingKeyword(text, startX, startY, targetRect, callback) {
        const el = document.createElement('div'); el.className = 'flying-keyword'; el.innerText = text;
        el.style.left = startX + 'px'; el.style.top = startY + 'px'; 
        el.style.transform = 'translate(-50%, -50%) scale(0.5)';
        document.body.appendChild(el);
        el.getBoundingClientRect();
        
        // PHASE 1: POP UP (Read Time)
        requestAnimationFrame(() => {
            el.style.opacity = '1';
            el.style.transform = 'translate(-50%, -50%) scale(1.5)'; // Pop big
        });

        // PHASE 2: FLY (After delay)
        setTimeout(() => {
            el.style.left = (targetRect.left + targetRect.width/2) + 'px'; 
            el.style.top = (targetRect.top + targetRect.height/2) + 'px';
            el.style.transform = 'translate(-50%, -50%) scale(1)';
        }, 800); // 0.8s delay to read

        // PHASE 3: CLEANUP
        setTimeout(() => { 
            el.style.opacity = '0';
            setTimeout(() => {
                el.remove(); if (callback) callback(); 
            }, 200);
        }, 800 + 2500); // Total time: Delay + Flight
    },
    removeExcessEggs(letter) {
        // REMOVE ALL EGGS OF THE COMPLETED LETTER
        const initialCount = this.entities.length;
        this.entities = this.entities.filter(e => {
            if (e.type === 'egg' && e.letter === letter) {
                this.addSplash(e.x, e.y); // Poof effect
                return false; // Remove it
            }
            return true; // Keep others
        });
    },
    processCatch(item) {
        this.entities = this.entities.filter(e => e !== item); this.hook.item = null;
        if (item.type === 'egg') {
            this.reactionState = 'happy'; this.reactionTimer = 120; 
            const msgs = ["Thank you!", "My baby!", "So happy!", "Wonderful!", "Great job!"];
            this.motherTurtleMessage = msgs[Math.floor(Math.random() * msgs.length)]; this.motherTurtleMessageTimer = 180; 
            const target = this.headlines.getTargetKeywordId(item.letter);
            if (target) {
                const canvasRect = this.canvas.getBoundingClientRect();
                const startX = canvasRect.left + this.hook.originX; const startY = canvasRect.top + this.hook.originY;
                const targetEl = document.getElementById(target.id); const targetRect = targetEl.getBoundingClientRect();
                this.spawnFlyingKeyword(target.text, startX, startY, targetRect, () => {
                    const res = this.headlines.revealKeyword(target.id);
                    if (res === 'COMPLETE') { 
                        this.score += 50; 
                        this.spawnFloat("BONUS! +50", '#4ade80', -30); 
                        // REMOVE EXCESS EGGS HERE
                        this.removeExcessEggs(item.letter);
                    }
                    if (this.headlines.isFullWin()) setTimeout(() => this.endGame(), 500);
                });
                this.score += item.value; AudioSys.playCatchEgg();
            } else { this.score += 5; this.spawnFloat(`+5`, '#cbd5e1'); }
        } else if (item.type === 'bomb') {
            this.shake = 20; this.reactionState = 'panic'; this.reactionTimer = 120; this.score += item.value; this.time = Math.max(0, this.time - 10);
            this.spawnFloat("-10s", '#ef4444'); AudioSys.playExplosion();
        } else if (item.type === 'fish') { this.score += item.value; this.spawnFloat("-5 Score", '#f472b6'); }
        else if (item.type === 'trash') { 
            this.score += item.value; this.showBadgeTimer = 120; this.spawnFloat("+15 CLEAN", '#38bdf8'); AudioSys.playCatchEgg();
        }
        this.updateUI();
    },
    spawnFloat(text, color, offset=0) {
        const d = document.createElement('div'); d.className = 'floating-text'; d.innerText = text; d.style.color = color;
        const r = this.canvas.getBoundingClientRect(); d.style.left = (r.left + this.hook.originX) + 'px'; d.style.top = (r.top + this.hook.originY + 50 + offset) + 'px';
        document.body.appendChild(d); setTimeout(() => d.remove(), 1200);
    },
    updateUI() {
        document.getElementById('scoreDisplay').innerText = this.score;
        const bar = document.getElementById('oxygenBar'); const txt = document.getElementById('oxygenText');
        const pct = Math.max(0, (this.time / CONFIG.GAME_TIME) * 100);
        bar.style.width = `${pct}%`; txt.innerText = `${Math.ceil(pct)}%`;
        if (pct < 20) bar.classList.add('critical'); else bar.classList.remove('critical');
    },
    drawBackground() {
        const ctx = this.ctx;
        const sky = ctx.createLinearGradient(0, 0, 0, this.height * 0.35); sky.addColorStop(0, '#0f172a'); sky.addColorStop(1, '#3b82f6');
        ctx.fillStyle = sky; ctx.fillRect(0, 0, this.width, this.height * 0.35);
        ctx.fillStyle = 'white';
        this.stars.forEach(s => { ctx.globalAlpha = 0.5 + Math.sin(this.frame * 0.1 + s.x * 10) * 0.5; ctx.beginPath(); ctx.arc(s.x * this.width, s.y * this.height, s.s * 2, 0, Math.PI*2); ctx.fill(); });
        ctx.globalAlpha = 1;
        // Moon
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.shadowColor = 'rgba(255, 255, 255, 0.5)'; ctx.shadowBlur = 20;
        ctx.beginPath(); ctx.arc(this.width - 80, 80, 40, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
        
        // Draw Lighthouse (Background)
        Visuals.drawLighthouse(ctx, this.width, this.height, this.frame);

        const seaH = this.height * 0.35; const sandStart = this.height * 0.7;
        const water = ctx.createLinearGradient(0, seaH, 0, sandStart); water.addColorStop(0, '#22d3ee'); water.addColorStop(0.3, '#4682B4'); water.addColorStop(1, '#1e3a8a');
        ctx.fillStyle = water; ctx.fillRect(0, seaH, this.width, sandStart - seaH);
        
        ctx.save(); ctx.globalCompositeOperation = 'overlay';
        const rayGrad = ctx.createLinearGradient(0, seaH, 0, this.height); rayGrad.addColorStop(0, 'rgba(255,255,255,0.15)'); rayGrad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = rayGrad; for (let i = 0; i < 6; i++) { const rx = (this.frame * 0.3 + i * 250) % (this.width + 400) - 200; ctx.beginPath(); ctx.moveTo(rx, seaH); ctx.lineTo(rx + 100, seaH); ctx.lineTo(rx - 100 + Math.sin(this.frame * 0.01)*50, this.height); ctx.lineTo(rx - 300 + Math.sin(this.frame * 0.01)*50, this.height); ctx.fill(); } ctx.restore();

        const sand = ctx.createLinearGradient(0, sandStart, 0, this.height); sand.addColorStop(0, '#F4A460'); sand.addColorStop(1, '#D2B48C');
        ctx.fillStyle = sand; ctx.beginPath(); ctx.moveTo(0, this.height); ctx.lineTo(0, sandStart);
        for (let x = 0; x <= this.width; x += 20) { const wave = Math.sin(x * 0.01) * 10 + Math.sin(x * 0.03 + this.frame * 0.02) * 5; ctx.lineTo(x, sandStart + wave); }
        ctx.lineTo(this.width, this.height); ctx.fill();
        ctx.fillStyle = "rgba(255, 255, 255, 0.15)"; for(let i=0; i<200; i++) { const rx = (Math.sin(i * 123.45) * 0.5 + 0.5) * this.width; const ry = sandStart + (Math.sin(i * 678.90) * 0.5 + 0.5) * (this.height - sandStart); ctx.beginPath(); ctx.arc(rx, ry, 1 + (i%2), 0, Math.PI*2); ctx.fill(); }

        // Draw Decorations
        this.decorations.forEach(d => { Visuals.drawDecoration(ctx, d.type, d.x, d.y, d.scale, this.frame); });

        // Seaweed (Decor)
        ctx.fillStyle = "rgba(20, 83, 45, 0.4)";
        for(let i=0; i<10; i++) { const sx = (i * 150) % this.width; const sy = this.height; const h = 60 + Math.sin(i)*20; const sway = Math.sin(this.frame * 0.05 + i) * 10; ctx.beginPath(); ctx.moveTo(sx, sy); ctx.quadraticCurveTo(sx + sway, sy - h/2, sx + sway/2, sy - h); ctx.quadraticCurveTo(sx - sway, sy - h/2, sx - 10, sy); ctx.fill(); }

        this.airplanes.forEach(a => a.draw(ctx));
        this.studentBoats.forEach(s => s.draw(ctx, this.frame));
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; for(let i=0; i<4; i++) { const waveY = seaH + Math.sin(this.frame * 0.05 + i) * 5; ctx.fillRect(0, waveY + i*5, this.width, 3); }
        this.seagulls.forEach(s => s.draw(ctx, this.frame));
    },
    loop() {
        this.frame++; this.ctx.clearRect(0, 0, this.width, this.height); 
        this.ctx.save();
        if (this.shake > 0) { const dx = (Math.random() - 0.5) * this.shake; const dy = (Math.random() - 0.5) * this.shake; this.ctx.translate(dx, dy); this.shake *= 0.9; if(this.shake < 0.5) this.shake = 0; }
        this.drawBackground();
        if (this.reactionTimer > 0) { this.reactionTimer--; if (this.reactionTimer <= 0) this.reactionState = 'none'; }
        if (this.motherTurtleMessageTimer > 0) { this.motherTurtleMessageTimer--; if (this.motherTurtleMessageTimer <= 0) this.motherTurtleMessage = null; }
        const isIdle = (Date.now() - this.lastActionTime > 5000);
        for(let i = this.particles.length - 1; i >= 0; i--) { let p = this.particles[i]; p.update(); p.draw(this.ctx); if(p.life <= 0) this.particles.splice(i, 1); }
        if (this.state === 'PLAYING') {
            if (Math.random() < 0.005) this.seagulls.push(new Seagull(this.width, this.height));
            for(let i = this.seagulls.length - 1; i >= 0; i--) { let s = this.seagulls[i]; s.update(this.width); if(!s.active) this.seagulls.splice(i, 1); }
            
            // Airplanes - INCREASED FREQUENCY to 0.003
            if (Math.random() < 0.003 && this.airplanes.length === 0) this.airplanes.push(new Airplane(this.width, this.height));
            for(let i = this.airplanes.length - 1; i >= 0; i--) { 
                let a = this.airplanes[i]; a.update(); 
                if(a.isOffScreen()) this.airplanes.splice(i, 1); 
            }

            if (Math.random() < 0.002 && this.studentBoats.length < 3) this.studentBoats.push(new StudentBoat(this.width, this.height));
            for(let i = this.studentBoats.length - 1; i >= 0; i--) { let s = this.studentBoats[i]; s.update(); if(s.isOffScreen()) this.studentBoats.splice(i, 1); }
            this.motherTurtleX += 0.3 * this.motherTurtleDir; if (this.motherTurtleX > this.width - 50) this.motherTurtleDir = -1; if (this.motherTurtleX < 50) this.motherTurtleDir = 1;
            Visuals.drawMotherTurtle(this.ctx, this.motherTurtleX, this.height * 0.7 - 20, this.frame, this.reactionState, this.motherTurtleDir, this.motherTurtleMessage);
            this.entities.forEach(e => e.update()); const caught = this.hook.update(this.entities, this.width, this.height); if (caught) this.processCatch(caught);
        } else { Visuals.drawMotherTurtle(this.ctx, this.width/2 - 100, this.height * 0.7 - 20, this.frame, 'none', 1, null); }
        this.entities.forEach(e => { if (!e.caught) e.draw(this.ctx, e.x, e.y, 0, this.frame); });
        this.hook.draw(this.ctx, this.frame, this.reactionState, isIdle); 
        if (this.showBadgeTimer > 0) { Visuals.drawBadge(this.ctx, this.frame, "CLEAN OCEAN"); this.showBadgeTimer--; }
        this.ctx.restore(); requestAnimationFrame(this.loop);
    }
};

game.init();
</script>
</body>
</html>